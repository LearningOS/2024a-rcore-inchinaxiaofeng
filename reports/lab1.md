# 实验报告

## 功能说明

我们需要分别获得（1）任务状态，（2）任务系统调用次数，（3）运行时间。依次分析：

* 任务状态：
  * 任务状态存在于`task/mod.rs`中的`TaskManager`下的`TaskManagerInner.tasks:TaskControlBlock`中的`task_status`，也就是`task/task.rs`下的内容。
  * 我们需要获得当前的Task ID,并用ID访问这个数组，获取当前的任务状态（不过一定是Running就是了）
  * 我在`task/mod.rs`中添加了一个方法，用于返回当前任务ID, 系统调用次数和状态。
  * 这个实验中，我们只需要次数和状态就可以了，当前ID不做要求，但是我还是做了。
* 任务系统调用次数：
  * 任务系统调用次数是跟每个任务相关的，所以我将它加入到了TaskControlBlock中，`syscall_times`，并且在`task/mod.rs`中初始化为0
  * 任何一个Trap处理都会在`trap/mod.rs`中的`trap_handler`函数中进行分发，当判断为系统调用的时候，会分发至`syscall/mod.rs`中的syscall函数中，进入这个函数才意味着，这个Trap是一个系统调用，所以我将计算`syscall_times`的函数调用放到了这里。
  * 我在`task/mod.rs`中添加了一个方法，传入当前的`syscall_id`，并且让计数加一。
* 运行时间
  * 我通过调用get_time_ms完成。

## 问答题

### 描述程序出错行为

* ch2b_bad_address:
  * 程序尝试访问无效地址，结果导致 PageFault 错误，显示错误地址为 0x0
* ch2b_bad_instruction:
  * 在执行过程中，该程序遇到非法指令，导致 IllegalInstruction 错误
* ch2b_bad_register:
  * 程序尝试访问不允许的寄存器，导致 IllegalInstruction 错误。

SBI版本:`RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0`

### 深入理解 trap.S 中两个函数

#### L40：刚进入`__restore`时，`a0`代表了什么值。请指出`__restore`的两种使用情景

alltrap中寄存器 a0 指向内核栈的栈指针也就是我们刚刚保存的 Trap 上下文的地址，这是由于我们接下来要调用 trap_handler 进行 Trap 处理，它的第一个参数 cx 由调用规范要从 a0 中获取，进入trap_handler后，将传入的Trap 上下文 cx 原样返回，因此在 __restore 的时候 a0 寄存器在调用 trap_handler 前后并没有发生变化，仍然指向分配 Trap 上下文之后的内核栈栈顶

场景：

* 从陷阱处理程序返回：在陷阱处理程序执行完毕后，可能会修改处理器状态，__restore 被调用来恢复被中断的进程的上下文。这包括恢复状态寄存器和通用寄存器的值，以便进程可以继续执行，仿佛陷阱没有发生过。
* 上下文切换：在处理完异常后从内核模式切换回用户模式时，__restore 负责恢复用户进程的状态。这对于确保用户进程能够正确恢复执行至关重要。

#### L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释

特殊处理的是`sstatus`、`sepc`、`sscratch`

* `sstatus`
  * sstatus寄存器用于保存当前状态，内部存有如中断使能等重要数据
* `sepc`
  * 用于sret的时候跳转的地址
* `sscratch`
  * 一个临时寄存器，这里是用于换栈的关键，决定了这个函数退出时，能不能正确的取得用户栈

> 原文解释：
> 在特权级切换的时候，我们需要将 Trap 上下文保存在内核栈上，因此需要一个寄存器暂存内核栈地址，并以它作为基地址指针来依次保存 Trap 上下文的内容。但是所有的通用寄存器都不能够用作基地址指针，因为它们都需要被保存，如果覆盖掉它们，就会影响后续应用控制流的执行。
>
> 事实上我们缺少了一个重要的中转寄存器，而 sscratch CSR 正是为此而生。从上面的汇编代码中可以看出，在保存 Trap 上下文的时候，它起到了两个作用：首先是保存了内核栈的地址，其次它可作为一个中转站让 sp （目前指向的用户栈的地址）的值可以暂时保存在 sscratch 。这样仅需一条 csrrw  sp, sscratch, sp 指令（交换对 sp 和 sscratch 两个寄存器内容）就完成了从用户栈到内核栈的切换，这是一种极其精巧的实现。

#### L50-L56：为何跳过了`x2`和`x4`？

x2也是sp指针，x4也是tp指针。

sp栈指针

#### L60：该指令之后，`sp`和`sscratch`中的值分别有什么意义？

sp 指向了用户栈，而sscratch指向了内核栈，后续的操作将在用户栈上

#### `__restore`中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？

是`sret`指令。这个指令将会从S Mode返回U Mode。原因是：
sret处理器会根据`sstatus`切换到U Mode,然后依据sepc跳转到用户程序。需要注意的是，sepc是在之前就分情况赋值了。见`trap.mod.rs`

#### L13：该指令之后，`sp`和`sscratch`中的值分别有什么意义？

换栈，sscratch中保存的是用户栈指针，将sp指向内核栈

#### 从`U`态进入`S`态是哪一条指令发生的？

ecall

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无。

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

无。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
