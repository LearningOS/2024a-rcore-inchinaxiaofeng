# 功能总结

我们需要实现如下的sysycall：

* sys_get_time
* sys_task_info
* sys_mmap
* sys_munmap

## sys_get_time

该函数获取当前系统时间（以微秒为单位），并将其封装为 TimeVal结构体。
通过安全的内存访问，将时间数据从内核空间复制到用户提供的缓冲区，从而允许用户进程获取当前时间。

## sys_task_info

此函数提供当前任务的状态信息，包括任务状态、系统调用次数以及任务的时间消耗。
信息同样通过 TaskInfo 结构体封装，并以安全的方式复制到用户提供的缓冲区，使得用户进程能够访问这些关键的任务信息。

## sys_mmap

* 功能
  * 该函数用于映射一段虚拟地址空间到物理内存。它需要确保传入的起始地址对齐、权限设置合理，并且指定的地址范围未被其他映射占用
* 参数检查
  * 确保起始地址页面对齐。
  * 检查权限位是否合法。
  * 确保映射范围内的页面没有被其他映射占用。
* 映射过程
  * 通过 create_new_map_area 函数创建新的映射区域，使用指定的权限。

## sys_munmap

* 功能
  *该函数用于解除映射，释放指定的虚拟地址区域。
* 参数检查：
  * 检查起始地址是否在合法范围内，并且页面对齐。
* 解除映射
  * 通过 unmap_consecutive_area 函数解除连续的映射区域。

# 问答题

## 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？

* Reserved\[63,54]
  * 保留
* PPN2\[53,28]
  * 物理页号
* PPN1\[27,19]
  * 物理页号
* PPN0\[18,10]
  * 物理页号
* RSW\[9,8]
  *
* D\[7]
  * 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过
* A\[6]
  * 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
* G\[5]
* U\[4]
  * 控制索引到这个页表项的对应的虚拟页面是否在CPU处于U特权级的情况下是否被允许访问
* X\[3]
  * 控制索引到这个页表项的对应的虚拟页面是否允许执行
* W\[2]
  * 控制索引到这个页表项的对应的虚拟页面是否允许写
* R\[1]
  * 控制索引到这个页表项的对应的虚拟页面是否允许读
* V\[0]
  * 仅V位为1时，页表项合法

## 缺页

### 缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程

* 请问哪些异常可能是缺页导致的？
  * **可能是因为访问未映射的内存**：进程试图访问未被分配的虚拟地址
  * **页面未加载**：进程访问的页面在内存中未加载，例如通过懒加载策略
  * **页面被换出**：访问的页面被换出到磁盘，页表项无效
* 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。

### 缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作

* 这样做有哪些好处？
  * **节省内存**：只有在需要的时候才加载页面，避免不需要的内存使用
  * **启动时间优化**：程序启动时，不会加载所有代码，降低启动延迟
  * **提高资源利用率**：通过仅加载必要的页面，减少物理内存的压力

### 其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作

* 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？
* 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。
  * **页表初始化**：当进程请求内存时，只在页表中记录虚拟地址到物理地址的映射，但不分配物理内存
  * **缺页处理**：当发生缺页异常时，操作系统捕获异常并执行页表更新，将所需页面从磁盘加载到物理内存，并更新页表项为有效
  * **页面替换算法**：需要实现页面替换算法，以管理物理内存的使用

### 缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效

* 此时页面失效如何表现在页表项(PTE)上？
当页面失效（例如被换出到磁盘）时，页表项的有效位会被清除，确保该页表项指向无效的物理地址。
此时，访问该页面将引发缺页异常。

## 双页表与单页表

### 为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )

* 在单页表情况下，如何更换页表？
  1. **进程切换**：当调度程序决定切换到另一个进程时，会加载该进程的页表基址到专用的寄存器，以便新的进程能够访问其自己的虚拟地址空间
  2. **系统调动**：当一个用户进程执行系统调用进入内核态时，操作系统可能需要加载不同的页表，特别是在处理不同权限的地址时
  3. **中断处理**：在处理硬件中断时，操作系统可能需要切换到一个特定的页表，以便访问相应的内核数据结构
* 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）
  1. **权限位设置**: 页表项中的权限位可以限制用户态进程对特定页框的访问。内核页的页表项可以设置为只允许内核态访问
  2. **用户态和内核态地址分离**: 操作系统在虚拟地址空间中为用户态和内核态分配不同的地址范围。用户态进程无法访问高于某一特定地址的内存区域
  3. **地址空间隔离**: 在切换到内核态时，操作系统会加载具有适当权限的页表，确保内核数据无法被用户态直接访问
* 单页表有何优势？（回答合理即可）
  * **简单**
  * **性能**
* 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？
  1. **进程切换**: 当操作系统切换到另一个进程时，需要加载新进程的页表基址，以确保新进程能够访问其自己的虚拟地址空间
  2. **系统调用或中断**: 处理系统调用或中断时，可能需要切换到特定的页表，以确保访问合适的内核数据结构
  3. **权限变更**: 如果进程的权限级别发生变化，例如从用户态切换到内核态，可能需要更换页表以适应新的访问权限要求

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
