# 问答题

## 需要回收的资源

当主线程（0 号线程）退出时，整个进程也需要退出，因此与该进程相关的所有线程和资源都需要被回收。具体需要回收的资源包括：

1. 线程资源：

* 线程的栈空间和堆空间。
* 线程的控制块（Task Control Block, TCB），用于管理线程的状态和调度信息。

2. 同步资源：

* 互斥量（Mutex）和信号量（Semaphore）等同步原语的状态和数据结构。
* 等待队列中可能被阻塞的线程信息。

3. 其他共享资源：

* 由该进程创建的任何文件描述符、网络连接、内存映射等。

## TaskControlBlock 的引用位置及回收

TaskControlBlock 可能在以下位置被引用：

1. 线程管理数据结构：

* 线程池或调度器的数据结构中，通常会有一个列表或数组存储所有活跃线程的 TCB。

2. 同步原语：

* 互斥锁或信号量的等待队列中，可能会引用到阻塞的线程的 TCB。

3. 其他数据结构：

* 如果使用了多个数据结构来管理线程（如优先队列等），这些结构中也可能会存储 TCB 引用。

## 是否需要回收

* 需要回收的引用：
  * 当主线程退出时，所有引用到该进程的 TCB 都需要被回收。这是因为这些 TCB 只在该进程的上下文中有效，进程结束后，这些资源也不再需要。
* 不需要回收的引用：
  * 如果有其他进程或线程持有该 TCB 的引用（例如，某些全局状态或共享数据结构），则这些引用需要根据具体实现决定是否需要回收。这种情况较为少见，通常在设计上会避免。

## Mutex.unlock 的实现对比

1. 实现1（Mutex1）：

```rust
impl Mutex for Mutex1 {
    fn unlock(&self) {
        let mut mutex_inner = self.inner.exclusive_access();
        assert!(mutex_inner.locked);
        mutex_inner.locked = false;
        if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
            add_task(waking_task);
        }
    }
}
```

2. 实现2（Mutex2）：

```rust
impl Mutex for Mutex2 {
    fn unlock(&self) {
        let mut mutex_inner = self.inner.exclusive_access();
        assert!(mutex_inner.locked);
        if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
            add_task(waking_task);
        } else {
            mutex_inner.locked = false;
        }
    }
}
```

## 区别与潜在问题

1. 锁的状态更新时机：

* Mutex1：在检查等待队列并唤醒任务后，才将 locked 状态设置为 false。
* Mutex2：只有在没有任务需要唤醒时，才将 locked 状态设置为 false。

2. 潜在问题：

* Mutex1 的实现确保了在唤醒一个等待任务之前，锁不会被释放。这意味着如果有任务在等待，它将首先被唤醒，这可以减少竞争条件的可能性，确保在锁释放后，等待的任务能够立即获取锁。
* Mutex2 的实现可能导致在没有任务被唤醒的情况下，锁被释放。这样的设计存在潜在的竞争条件问题，因为如果后续的线程在锁被释放后立即尝试获取锁，可能会导致不一致的状态或错误的行为，特别是在高并发环境下。

# 荣誉

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
